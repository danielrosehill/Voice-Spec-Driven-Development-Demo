"""Agent 2: Repository Creation using GitHub MCP"""

import os
import base64
import asyncio
from pathlib import Path
from typing import Optional
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client
import git
from ..state import ProjectState, AgentStatus


class GitHubMCPClient:
    """Client for interacting with GitHub MCP server - simplified wrapper"""

    def __init__(self):
        self.github_token = os.getenv("GITHUB_TOKEN")
        if not self.github_token:
            raise ValueError("GITHUB_TOKEN environment variable not set")

        self.server_params = StdioServerParameters(
            command="npx",
            args=["-y", "@modelcontextprotocol/server-github"],
            env={"GITHUB_PERSONAL_ACCESS_TOKEN": self.github_token}
        )

    async def create_repository(
        self,
        session: ClientSession,
        name: str,
        description: str,
        private: bool = True
    ) -> dict:
        """Create a new GitHub repository"""
        result = await session.call_tool(
            "create_repository",
            arguments={
                "name": name,
                "description": description,
                "private": private,
                "auto_init": True
            }
        )
        # Parse response
        import json
        return json.loads(result.content[0].text)

    async def create_file(
        self,
        session: ClientSession,
        owner: str,
        repo: str,
        path: str,
        content: str,
        message: str,
        branch: str = "main"
    ) -> dict:
        """Create or update a file in repository"""
        # Encode content to base64
        content_encoded = base64.b64encode(content.encode()).decode()

        result = await session.call_tool(
            "create_or_update_file",
            arguments={
                "owner": owner,
                "repo": repo,
                "path": path,
                "content": content_encoded,
                "message": message,
                "branch": branch
            }
        )

        import json
        return json.loads(result.content[0].text)


class RepoCreationAgent:
    """
    Agent 2: Creates GitHub repository and initializes structure
    Uses GitHub MCP for repository operations
    """

    def __init__(self):
        self.repos_base = Path.home() / "repos" / "github"
        self.repos_base.mkdir(parents=True, exist_ok=True)

    def generate_claude_md(self, state: ProjectState) -> str:
        """Generate CLAUDE.md content for the repository"""
        tech_req = state.get("tech_requirements", {})

        languages = ", ".join(tech_req.get("languages", []))
        frameworks = ", ".join(tech_req.get("frameworks", []))
        dependencies = "\n".join(f"- {dep}" for dep in tech_req.get("dependencies", []))

        features = "\n".join(f"- {feat}" for feat in state.get("features", []))

        return f"""# {state['project_name']}

## Project Description

{state['project_description']}

## Development Specification

{state['dev_specification']}

## Technical Requirements

### Languages and Frameworks
{languages}
{frameworks}

### Dependencies
{dependencies}

### Architecture
{tech_req.get('architecture', 'Not specified')}

## Features

{features}

## Development Guidelines

### Code Style
- Follow language-specific best practices
- Maintain consistent formatting
- Write descriptive commit messages

### Testing
- Write unit tests for new features
- Maintain test coverage above 80%
- Run tests before committing

### Documentation
- Document all public APIs
- Keep README up to date
- Add inline comments for complex logic

## Project Context for AI Assistants

This project was initialized using Voice-Spec-Driven Development.
The specification above was derived from an audio recording and
should serve as the primary reference for project requirements.

When working on this project:
1. Refer to the specification for feature requirements
2. Follow the technical requirements for implementation
3. Maintain consistency with established patterns
4. Ask for clarification on ambiguous requirements

---

Generated by Voice-Spec-Driven Development
"""

    def clone_repository(self, repo_url: str, project_name: str) -> str:
        """Clone repository to local machine"""
        local_path = self.repos_base / project_name

        # Remove if exists
        if local_path.exists():
            import shutil
            shutil.rmtree(local_path)

        # Clone
        git.Repo.clone_from(repo_url, local_path)
        return str(local_path)

    async def execute_async(self, state: ProjectState) -> ProjectState:
        """Execute Agent 2: Repository Creation (async)"""
        print("ðŸ“¦ Agent 2: Creating GitHub repository...")
        state["current_agent"] = "agent_2_repo_creation"
        state["agent_2_status"] = AgentStatus.IN_PROGRESS

        try:
            github_client = GitHubMCPClient()

            # Use nested async context managers properly
            async with stdio_client(github_client.server_params) as (read, write):
                async with ClientSession(read, write) as session:
                    await session.initialize()

                    # Create repository
                    print(f"   Creating repository: {state['project_name']}")
                    repo_result = await github_client.create_repository(
                        session=session,
                        name=state["project_name"],
                        description=state["project_description"],
                        private=True
                    )

                    state["repo_url"] = repo_result["html_url"]
                    state["repo_owner"] = repo_result["owner"]["login"]
                    print(f"   âœ“ Repository created: {repo_result['html_url']}")

                    # Generate CLAUDE.md
                    print("   Generating CLAUDE.md...")
                    claude_md = self.generate_claude_md(state)
                    state["claude_md_content"] = claude_md

                    # Create CLAUDE.md in repository
                    await github_client.create_file(
                        session=session,
                        owner=state["repo_owner"],
                        repo=state["project_name"],
                        path="CLAUDE.md",
                        content=claude_md,
                        message="Add CLAUDE.md with project context"
                    )
                    print("   âœ“ CLAUDE.md created in repository")

                    # Clone repository locally
                    print(f"   Cloning repository to {self.repos_base}...")
                    local_path = self.clone_repository(
                        repo_url=repo_result["clone_url"],
                        project_name=state["project_name"]
                    )
                    state["local_repo_path"] = local_path
                    print(f"   âœ“ Repository cloned to: {local_path}")

                    state["agent_2_status"] = AgentStatus.COMPLETED
                    state["initial_files_created"] = ["CLAUDE.md", "README.md"]

        except Exception as e:
            state["agent_2_status"] = AgentStatus.FAILED
            state["errors"].append(f"Agent 2 failed: {str(e)}")
            print(f"   âœ— Error: {str(e)}")
            raise

        return state

    def execute(self, state: ProjectState) -> ProjectState:
        """Execute Agent 2 (sync wrapper)"""
        return asyncio.run(self.execute_async(state))


def agent2_node(state: ProjectState) -> ProjectState:
    """LangGraph node for Agent 2"""
    agent = RepoCreationAgent()
    return agent.execute(state)
